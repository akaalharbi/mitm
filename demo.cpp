//
// Credit Charles Bouillageut
//
#include "mitm_sequential.hpp"
#include <iostream>

/******************************************************************************/
/* Simple concrete example                                                    */
/******************************************************************************/





//
class IntDomain : AbstractDomain<unsigned int> {
public:
    using A = IntDomain;
    using t = unsigned int;
    template<class PRNG>
    void randomize(t &x, PRNG &p) const { x = p.rand(); }
    bool is_equal(const t &x, const t &y) const { return x == y; };
    int length = 4;
    const static size_t n_elements = (1LL<<32);

    inline void next(t& x)  const { x = x+1; }
    void serialize(const t &x, void *out) const {
        t *tmp = static_cast<t*>(out);
        *tmp = x;
    }
    void unserialize(t &x, void *in) const {
        t *tmp = static_cast<t*>(in);
        x = *tmp;
    }
    uint64_t hash(const t &x) const { return x; }
    uint64_t hash_extra(const t &x) const { return 0; }
};

class Problem : AbstractProblem<IntDomain> {
private:


public:
    IntDomain dom;
    using A = IntDomain;
    using A_t = unsigned int;

    Problem(IntDomain & dom) : dom(dom) {};

    inline void f(const unsigned int &x, unsigned int &y) const
    {
        y = 42 * x * x + 1337;
    }
};

/******************************************************************************/

int main()
{
    IntDomain dom;          // create an instance of the domain
    Problem pb(dom);        // create an instance of the problem

    /*
     * I looked at the assembler code generated by gcc:
     * f is correctly inlined starting with -O1
     */
    std::pair result = collision(pb);

    std::cout << "x = " << result.first << " and y = " << result.second << std::endl;
    unsigned int fx, fy;
    pb.f(result.first, fx);
    pb.f(result.second, fy);
    std::cout << "f(x) = " << fx << " and f(y) = " << fy << std::endl;

    assert(fx == fy && result.first != result.second);
    return 0;
}
